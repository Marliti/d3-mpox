<script>
/* ---------- Thème ---------- */
const rootEl = document.documentElement;
const themeToggle = document.getElementById("themeToggle");
const savedTheme = localStorage.getItem("theme") || "auto";
rootEl.setAttribute("data-theme", savedTheme);
themeToggle.checked = (savedTheme === "light") || (savedTheme === "auto" && matchMedia('(prefers-color-scheme: light)').matches);
themeToggle.addEventListener("change", () => {
  const val = themeToggle.checked ? "light" : "dark";
  rootEl.setAttribute("data-theme", val);
  localStorage.setItem("theme", val);
});

/* ---------- Éléments UI ---------- */
const svg = d3.select(".chart");
const statusEl = document.getElementById("status");
const departementSelect = document.getElementById("departementSelect");
const districtSelect = document.getElementById("districtSelect");
const tooltip = document.getElementById("tooltip");
const durSlider = document.getElementById("durSlider");
const durVal = document.getElementById("durVal");
const uploadWrap = document.getElementById("uploadWrap");
const fileInput = document.getElementById("file");
const btnSvg = document.getElementById("btnSvg");
const btnPng = document.getElementById("btnPng");
const chkTrend = document.getElementById("chkTrend");
const chkSmooth = document.getElementById("chkSmooth");
const smoothWin = document.getElementById("smoothWin");
const smoothVal = document.getElementById("smoothVal");

const margin = {top: 28, right: 30, bottom: 64, left: 64};
let DUR = +durSlider.value, EASE = d3.easeCubic;
let allRows = [], currentData = [];
let zx, xIndex, y;

durSlider.addEventListener("input", () => { DUR = +durSlider.value; durVal.textContent = DUR; });
smoothWin.addEventListener("input", () => { smoothVal.textContent = smoothWin.value; drawChart(currentData, true); });
chkTrend.addEventListener("change", () => drawChart(currentData, true));
chkSmooth.addEventListener("change", () => drawChart(currentData, true));

/* ---------- Responsive ---------- */
function getSize(){
  const { width } = svg.node().getBoundingClientRect();
  const height = width / (16/9);
  svg.attr("viewBox", `0 0 ${width} ${height}`);
  return {W: width, H: height};
}
window.addEventListener("resize", () => drawChart(currentData, true));

/* ---------- Chargement CSV ---------- */
loadHostedCSV("df.csv")
  .then(rows => { statusEl.textContent = `OK – ${rows.length} lignes`; init(rows); })
  .catch(() => { statusEl.textContent = "df.csv introuvable — charge un CSV local."; uploadWrap.classList.remove("hidden"); });

fileInput?.addEventListener("change", (e) => {
  const f = e.target.files[0]; if(!f) return;
  statusEl.textContent = `Chargement local: ${f.name}…`;
  const reader = new FileReader();
  reader.onload = () => { const rows = d3.dsvFormat(";").parse(reader.result); statusEl.textContent = `Lignes: ${rows.length}`; init(rows); };
  reader.readAsText(f, "utf-8");
});
async function loadHostedCSV(path){ return d3.dsv(";", `${path}?v=${Date.now()}`); }

/* ---------- Init & Filtres ---------- */
function init(rows){
  allRows = rows;
  const deps = Array.from(new Set(allRows.map(d => d.Departements?.trim()).filter(Boolean))).sort();
  departementSelect.innerHTML = `<option value="">(Tous)</option>` + deps.map(dep => `<option>${dep}</option>`).join("");
  districtSelect.innerHTML = `<option value="">(Tous)</option>`;
  departementSelect.onchange = updateDistrictOptions;
  districtSelect.onchange = () => updateChart(false);
  updateChart(true);
}
function updateDistrictOptions(){
  const dep = departementSelect.value;
  const filtered = dep ? allRows.filter(d => (d.Departements||"").trim() === dep) : allRows;
  const dists = Array.from(new Set(filtered.map(d => d.Districts_Sanitaires?.trim()).filter(Boolean))).sort();
  districtSelect.innerHTML = `<option value="">(Tous)</option>` + dists.map(ds => `<option>${ds}</option>`).join("");
  updateChart(false);
}
function updateChart(first=false){
  let rows = allRows.map(d => ({
    ...d,
    cas_suspect:+d.cas_suspect||0, cas_confirme:+d.cas_confirme||0,
    Year_Week:(d.Year_Week||"").trim(),
    Departements:(d.Departements||"").trim(),
    Districts_Sanitaires:(d.Districts_Sanitaires||"").trim()
  })).filter(d=>d.Year_Week);
  if(departementSelect.value) rows = rows.filter(d => d.Departements === departementSelect.value);
  if(districtSelect.value) rows = rows.filter(d => d.Districts_Sanitaires === districtSelect.value);

  const grouped = d3.rollups(rows, v => ({
    cas_suspect:d3.sum(v,d=>d.cas_suspect),
    cas_confirme:d3.sum(v,d=>d.cas_confirme)
  }), d=>d.Year_Week).map(([k,v])=>({Year_Week:k,...v}));

  grouped.sort((a,b)=>{ const pa=parseYW(a.Year_Week), pb=parseYW(b.Year_Week); return pa.year-pb.year || pa.week-pb.week; });

  currentData = grouped;
  drawChart(grouped, first);
}

/* ---------- Dessin ---------- */
function drawChart(data, first=false){
  svg.selectAll("*").remove();
  const {W, H} = getSize(), innerW = W - margin.left - margin.right, innerH = H - margin.top - margin.bottom;
  const root = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

  // Stats de base
  const n = data.length;
  const xs = d3.range(n);
  const ys = data.map(d=>d.cas_confirme);

  // Régression + IC + projection (calculs avant l'échelle Y)
  let reg=null, ciPairs=[], forecastPts=[];
  const forecastWeeks = 8;
  if(chkTrend.checked && n>=3){
    reg = linregFull(xs, ys); // {a,b,r2,s,xbar,Sxx}
    // t critique 95% (approx) : 1.96 si n>=30, sinon ~2.262 (df≈n-2)
    const tcrit = (n>=30) ? 1.96 : 2.262;

    // CI 95% pour la moyenne : ŷ ± tcrit * s * sqrt(1/n + (x-x̄)^2 / Sxx)
    ciPairs = xs.map(i => {
      const yhat = reg.a + reg.b * i;
      const seMean = reg.s * Math.sqrt( (1/n) + ((i - reg.xbar)**2) / (reg.Sxx || 1e-9) );
      return { i, upper: yhat + tcrit*seMean, lower: yhat - tcrit*seMean };
    });

    // Projection +1…+8 semaines
    forecastPts = d3.range(1, forecastWeeks+1).map(k => {
      const i = (n-1) + k;
      return { i, y: reg.a + reg.b * i };
    });
  }

  // Domaine Y (prend en compte CI et projection)
  const yMaxData = d3.max(data, d => Math.max(d.cas_confirme, d.cas_suspect)) || 1;
  const yMaxCI   = ciPairs.length ? d3.max(ciPairs, d=>d.upper) : 0;
  const yMaxF    = forecastPts.length ? d3.max(forecastPts, d=>d.y) : 0;
  const yMax     = Math.max(yMaxData, yMaxCI, yMaxF);
  y = d3.scaleLinear().domain([0, yMax * 1.08]).nice().range([innerH, 0]);

  // X (domaine [0,n], extrapolation OK pour la projection)
  xIndex = d3.scaleLinear().domain([0, n]).range([0, innerW]); zx = xIndex.copy();

  const baseBarPad = 0.88;
  const barX = i => zx(i);
  const barW = i => Math.max(1, Math.abs(zx(i+1) - zx(i)) * baseBarPad);
  const barCenter = i => zx(i) + barW(i)/2;

  // Grille
  root.append("g").attr("class","grid").call(d3.axisLeft(y).ticks(6).tickSize(-innerW).tickFormat("")).selectAll("line").attr("opacity", .6);

  const overlayG = root.append("g"), barsG=root.append("g"), lineG=root.append("g"), dotsG=root.append("g"),
        extrasG=root.append("g"), annotG=root.append("g");
  const axisXG = root.append("g").attr("class","axis").attr("transform", `translate(0,${innerH})`);
  const axisYG = root.append("g").attr("class","axis");

  // Barres confirmés
  barsG.selectAll("rect").data(data, d=>d.Year_Week).join(
    enter => enter.append("rect").attr("class","bar").attr("fill","var(--confirme)")
      .attr("x",(d,i)=>barX(i)+(Math.abs(zx(i+1)-zx(i))-barW(i))/2)
      .attr("width",(d,i)=>barW(i)).attr("y",y(0)).attr("height",0)
      .on("mouseenter",(e,d)=>showTip(d)).on("mouseleave",hideTip).on("mousemove",moveTip)
      .call(en=>en.transition().duration(first?0:DUR).ease(EASE)
        .attr("y",d=>y(d.cas_confirme)).attr("height",d=>y(0)-y(d.cas_confirme))),
    update => update.on("mouseenter",(e,d)=>showTip(d)).on("mouseleave",hideTip).on("mousemove",moveTip)
      .call(up=>up.transition().duration(first?0:DUR).ease(EASE)
        .attr("x",(d,i)=>barX(i)+(Math.abs(zx(i+1)-zx(i))-barW(i))/2).attr("width",(d,i)=>barW(i))
        .attr("y",d=>y(d.cas_confirme)).attr("height",d=>y(0)-y(d.cas_confirme))),
    exit => exit.call(ex=>ex.transition().duration(Math.max(150,DUR/1.3)).ease(EASE).attr("y",y(0)).attr("height",0).style("opacity",0).remove())
  );

  // Ligne + points suspects
  const lineGen = d3.line().x((d,i)=>barCenter(i)).y(d=>y(d.cas_suspect)).curve(d3.curveMonotoneX);
  const path = lineG.append("path").datum(data).attr("fill","none").attr("stroke","var(--suspect)").attr("stroke-width",2);
  const oldD = path.attr("d") || lineGen(data), newD = lineGen(data);
  path.attr("d", oldD).transition().duration(first?0:DUR).ease(EASE).attrTween("d", ()=> {
    const i = d3.interpolateString(oldD, newD); return t => i(t);
  });
  dotsG.selectAll("circle").data(data, d=>d.Year_Week).join(
    en => en.append("circle").attr("class","dot").attr("r",0).attr("fill","var(--suspect)")
      .attr("cx",(d,i)=>barCenter(i)).attr("cy",d=>y(d.cas_suspect))
      .on("mouseenter",(e,d)=>showTip(d,true)).on("mouseleave",hideTip).on("mousemove",moveTip)
      .call(en=>en.transition().duration(first?0:DUR).ease(EASE).attr("r",3).style("opacity",1)),
    up => up.on("mouseenter",(e,d)=>showTip(d,true)).on("mouseleave",hideTip).on("mousemove",moveTip)
      .call(up=>up.transition().duration(first?0:DUR).ease(EASE).attr("cx",(d,i)=>barCenter(i)).attr("cy",d=>y(d.cas_suspect)).style("opacity",1)),
    ex => ex.call(ex=>ex.transition().duration(Math.max(150,DUR/1.3)).ease(EASE).attr("r",0).style("opacity",0).remove())
  );

  // Régression + IC + projection
  let regStats = null, smoothStats = null;
  if(reg){
    regStats = {a:reg.a, b:reg.b, r2:reg.r2};

    // Bande IC95% correcte (upper/lower synchronisés)
    const area = d3.area()
      .x(d => barCenter(d.i))
      .y0(d => y(d.lower))
      .y1(d => y(d.upper))
      .curve(d3.curveMonotoneX);

    extrasG.append("path")
      .datum(ciPairs)
      .attr("fill","var(--trendBand)")
      .attr("stroke","none")
      .attr("d", area)
      .attr("opacity",0)
      .transition().duration(first?0:DUR).attr("opacity",1);

    // Ligne de tendance
    const trendPts = xs.map(i => ({i, y: reg.a + reg.b*i}));
    const trendLine = d3.line().x(d=>barCenter(d.i)).y(d=>y(d.y)).curve(d3.curveMonotoneX);
    extrasG.append("path")
      .datum(trendPts)
      .attr("fill","none").attr("stroke","var(--trend)").attr("stroke-width",2.5)
      .attr("d", trendLine)
      .attr("opacity",0).transition().duration(first?0:DUR).attr("opacity",1);

    // Projection (pointillée) +1…+8 semaines
    if(forecastPts.length){
      const fLine = d3.line().x(d=>barCenter(d.i)).y(d=>y(d.y));
      extrasG.append("path")
        .datum([{i:n-1, y: reg.a + reg.b*(n-1)}, ...forecastPts])
        .attr("fill","none").attr("stroke","var(--forecastDash)").attr("stroke-width",2.5).attr("stroke-dasharray","6,6")
        .attr("d", fLine)
        .attr("opacity",0).transition().duration(first?0:DUR).attr("opacity",1);
    }
  }

  // Lissage (optionnel)
  if(chkSmooth.checked && n>=3){
    const k = Math.max(3, (+smoothWin.value|0) || 5);
    const sm = movingAverage(ys, k);
    const smPts = sm.map((yhat,i)=>({i,y:yhat})).filter(d=>!Number.isNaN(d.y));
    if(smPts.length){
      const smLine = d3.line().x(d=>barCenter(d.i)).y(d=>y(d.y)).curve(d3.curveMonotoneX);
      extrasG.append("path").datum(smPts)
        .attr("fill","none").attr("stroke","var(--smooth)").attr("stroke-width",2)
        .attr("d", smLine).attr("opacity",0)
        .transition().duration(first?0:DUR).attr("opacity",1);
      const L = smPts.length, last=smPts[L-1].y, prev=smPts[L-2]?.y ?? NaN;
      smoothStats = {k, last, delta: last - (isNaN(prev)? last : prev)};
    }
  }

  // Axes + titres
  axisYG.call(d3.axisLeft(y).ticks(6));
  updateAxisXTicks();
  svg.append("text").attr("transform","rotate(-90)").attr("y",18).attr("x",-(H/2)).attr("dy","1em").style("text-anchor","middle").style("fill","var(--text)").text("Nombre de cas");
  svg.append("text").attr("transform",`translate(${(W/2)}, ${H-10})`).style("text-anchor","middle").style("fill","var(--text)").text("Semaine épidémiologique (Year_Week)");

  // Annotation
  addAnnotation(annotG, innerW, innerH, regStats, smoothStats);

  // Axe X dynamique
  function updateAxisXTicks(){
    const visStart = Math.max(0, Math.floor(zx.invert(0)));
    const visEnd = Math.min(n, Math.ceil(zx.invert(innerW)));
    const visible = data.slice(visStart, visEnd).map((d,i)=>({idx:visStart+i,label:d.Year_Week}));
    const maxTicks = 16, step = Math.max(1, Math.ceil(visible.length / maxTicks));
    const ticks = visible.filter((_,i)=> i%step===0);
    axisXG.call(d3.axisBottom(d3.scaleLinear().domain([0, innerW]).range([0, innerW]))
      .tickValues(ticks.map(t=>zx(t.idx))).tickFormat((_,i)=>ticks[i]?.label ?? ""))
      .selectAll("text").attr("transform","rotate(-35)").style("text-anchor","end");
  }

  // Zoom/Pan
  function renderOnlyPositions(){
    barsG.selectAll("rect")
      .attr("x",(d,i)=>barX(i)+(Math.abs(zx(i+1)-zx(i))-barW(i))/2)
      .attr("width",(d,i)=>barW(i));
    lineG.selectAll("path").attr("d", lineGen);
    dotsG.selectAll("circle").attr("cx",(d,i)=>barCenter(i)).attr("cy",d=>y(d.cas_suspect));
    // IC, tendance, projection suivent automatiquement via les accessors
    extrasG.selectAll("path").attr("opacity",1);
    updateAxisXTicks();
  }
  const zoom = d3.zoom().scaleExtent([1,20]).translateExtent([[0,0],[innerW,innerH]]).extent([[0,0],[innerW,innerH]])
    .on("zoom", (event)=>{ zx = event.transform.rescaleX(xIndex); renderOnlyPositions(); });
  const overlay = overlayG.append("rect").attr("width", innerW).attr("height", innerH).attr("fill","transparent").style("cursor","grab");
  overlay.lower(); svg.call(zoom); overlay.on("dblclick", ()=> svg.transition().duration(250).call(zoom.transform, d3.zoomIdentity));
}

/* ---------- Annotation helper ---------- */
function addAnnotation(g, innerW, innerH, reg, sm){
  g.selectAll("*").remove();
  const pad = 10, boxW = 270, x = innerW - boxW - 8, y = 8;
  const lines = [];
  const f2 = d3.format(".2f"), f3 = d3.format(".3f"), sgn = v => v>0 ? "↑" : v<0 ? "↓" : "≈";
  if(reg){
    lines.push("Régression (confirmés ~ semaine)");
    lines.push(`y = ${f2(reg.a)} ${reg.b>=0?"+":"-"} ${f2(Math.abs(reg.b))}·semaine`);
    lines.push(`R² = ${f3(reg.r2)}   tendance: ${sgn(reg.b)}`);
    lines.push(`Projection: +1…+8 sem (pointillé)`);
  }
  if(sm){
    lines.push(`Lissage (k = ${sm.k})`);
    lines.push(`dernier = ${f2(sm.last)}   Δ = ${f2(sm.delta)}`);
  }
  if(!lines.length) return;
  const box = g.append("g").attr("transform", `translate(${x},${y})`);
  const rect = box.append("rect").attr("rx",8).attr("ry",8).attr("width",boxW).attr("height",10).attr("fill","var(--panel)").attr("stroke","var(--grid)");
  const text = box.append("text").attr("x", pad).attr("y", pad+2).attr("fill", "var(--text)").style("font","12px system-ui");
  lines.forEach((t,i)=> text.append("tspan").attr("x",pad).attr("dy", i?16:0).text(t) );
  const bbox = text.node().getBBox(); rect.attr("height", bbox.height + pad*2);
}

/* ---------- Stats helpers ---------- */
function linregFull(xs, ys){
  const n = xs.length;
  const sumX = d3.sum(xs), sumY = d3.sum(ys);
  const xbar = sumX/n, ybar = sumY/n;
  let Sxx=0, Sxy=0, SSE=0, SST=0;
  for(let i=0;i<n;i++){ const dx=xs[i]-xbar, dy=ys[i]-ybar; Sxx+=dx*dx; Sxy+=dx*dy; }
  const b = Sxy / (Sxx || 1e-9);
  const a = ybar - b*xbar;
  for(let i=0;i<n;i++){ const yhat = a + b*xs[i]; SSE += (ys[i]-yhat)**2; SST += (ys[i]-ybar)**2; }
  const s = Math.sqrt( SSE / Math.max(1, n-2) ); // erreur standard résiduelle
  const r2 = (SST === 0) ? 1 : Math.max(0, 1 - SSE/SST);
  return {a,b,r2,s,xbar,Sxx};
}
// moyenne mobile centrée (fenêtre impaire k)
function movingAverage(arr, k){
  const out = new Array(arr.length).fill(NaN);
  const r = Math.floor(k/2);
  for(let i=0;i<arr.length;i++){
    let s=0,c=0;
    for(let j=i-r;j<=i+r;j++){ if(j>=0 && j<arr.length){ s+=arr[j]; c++; } }
    if(c>0) out[i]=s/c;
  }
  return out;
}

/* ---------- Infobulles ---------- */
function showTip(d){
  const total = d.cas_confirme + d.cas_suspect;
  tooltip.innerHTML = `<strong>${d.Year_Week}</strong><br/>confirmés : <b>${d.cas_confirme}</b><br/>suspects : <b>${d.cas_suspect}</b><br/>total : <b>${total}</b>`;
  tooltip.style.opacity = 1;
}
function moveTip(e){ tooltip.style.left = e.clientX + "px"; tooltip.style.top = e.clientY + "px"; }
function hideTip(){ tooltip.style.opacity = 0; }

/* ---------- Export SVG & PNG ---------- */
function getInlineStyles(){ let css=""; for(const s of document.styleSheets){ try{ for(const r of s.cssRules){ css+=r.cssText+"\n"; } }catch(e){} } return css; }
function cloneCurrentSVG(){ const node=document.querySelector("svg.chart"); const clone=node.cloneNode(true); const st=document.createElement("style"); st.type="text/css"; st.textContent=getInlineStyles(); clone.insertBefore(st, clone.firstChild); return clone; }
function downloadBlob(blob, name){ const a=document.createElement("a"); const url=URL.createObjectURL(blob); a.href=url; a.download=name; document.body.appendChild(a); a.click(); setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); },0); }

btnSvg.addEventListener("click", () => {
  const clone=cloneCurrentSVG(), ser=new XMLSerializer(); let svgStr=ser.serializeToString(clone);
  if(!svgStr.match(/^<svg[^>]+xmlns=/)){ svgStr=svgStr.replace(/^<svg/,'<svg xmlns="http://www.w3.org/2000/svg"'); }
  downloadBlob(new Blob([svgStr],{type:"image/svg+xml;charset=utf-8"}), `mpox_${new Date().toISOString().slice(0,10)}.svg`);
});
btnPng.addEventListener("click", async () => {
  const clone=cloneCurrentSVG(); const vb=clone.getAttribute("viewBox")?.split(" ").map(Number)||[0,0,1100,1100/16*9];
  const w=vb[2], h=vb[3], scale=2; const canvas=document.createElement("canvas"); canvas.width=w*scale; canvas.height=h*scale; const ctx=canvas.getContext("2d");
  const theme=rootEl.getAttribute("data-theme"); const light = theme==="light" || (theme==="auto" && matchMedia('(prefers-color-scheme: light)').matches);
  ctx.fillStyle = light ? "#ffffff" : "#0f172a"; ctx.fillRect(0,0,canvas.width,canvas.height);
  const ser=new XMLSerializer(); let svgStr=ser.serializeToString(clone); if(!svgStr.match(/^<svg[^>]+xmlns=/)){ svgStr=svgStr.replace(/^<svg/,'<svg xmlns="http://www.w3.org/2000/svg"'); }
  const url=URL.createObjectURL(new Blob([svgStr],{type:"image/svg+xml;charset=utf-8"})); const img=new Image();
  img.onload=()=>{ ctx.drawImage(img,0,0,canvas.width,canvas.height); URL.revokeObjectURL(url);
    canvas.toBlob(b=>downloadBlob(b,`mpox_${new Date().toISOString().slice(0,10)}.png`),"image/png"); };
  img.onerror=()=>{ alert("Erreur lors du rendu PNG."); URL.revokeObjectURL(url); };
  img.src=url;
});

/* ---------- Helpers ---------- */
function parseYW(s){ const m=/(\d{4})\D+(\d+)/.exec(s||""); return {year:m?+m[1]:0, week:m?+m[2]:0}; }
</script>
